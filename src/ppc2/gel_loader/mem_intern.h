#ifndef __MEM_INTERN_H__
#define __MEM_INTERN_H__

#include <ppc/api.h>

// taken from mem.c generated by gliss2
// it is mainly template code, so update needed only if change in gliss2
// not if nmp changed
// code is tranlated into C++ (Exception thrown for errors)

/* MEMORY REPRESENTATION */

/* WARNING: constant below be multiple of 8 bytes ! */

/* memory page size */
#define MEMORY_PAGE_SIZE 4096
/* primary hash table size */
#define PRIMARYMEMORY_HASH_TABLE_SIZE 4096
/* secondary hash table size */
#define SECONDARYMEMORY_HASH_TABLE_SIZE 16

/*
 * Memory is allocated dynamically when needed.
 * The memory is organized as:
 *
 *  |-------------|
 *  |             |
 *  |-------------|
 *  |             |
 *  |-------------|
 *  |             |
 *  |-------------|
 *  |      -------|------->|-------|
 *  |-------------|        |   ----|---> list of pairs(address +
 *  |             |        |-------|                   MEMORY_PAGE_SIZE bytes)
 *  |-------------|        |       |
 *  |             |        |-------|
 *  |-------------|          ....
 *  |             |
 *  |-------------|
 *      ....
 *   ^ primary hastable       ^ secondary hashtable
 *
 * the hash method works as :
 *
 * memory address is hashed like that
 *
 *  ..----|----|------------|------------|
 *     4    3        2            1
 * 1 -> the address inside the page
 * 2 -> the address corresponding to the primary hash code
 * 3 -> the address corresponding to the secondary hash code
 * 4 -> inside the "list of pairs" described overhead
 */
typedef struct memory_page_table_entry_t  {
	ppc_address_t addr;
	struct memory_page_table_entry_t *next;
	uint8_t *storage;
} memory_page_table_entry_t;

typedef struct  {
	memory_page_table_entry_t *pte[SECONDARYMEMORY_HASH_TABLE_SIZE];
} secondary_memory_hash_table_t;

struct ppc_memory_t {
	void* image_link; /* link to a generic image data resource of the memory
	                     it permits to fetch informations about image structure
	                     via an optionnal external system */
    secondary_memory_hash_table_t *primary_hash_table[PRIMARYMEMORY_HASH_TABLE_SIZE];
};
typedef struct ppc_memory_t memory_64_t;


/**
 * Compute hash level 1.
 * @param addr	Address to hash.
 * @return		Hash value.
 */
uint32_t mem_hash1(ppc_address_t addr)  {
    return (addr / MEMORY_PAGE_SIZE) % PRIMARYMEMORY_HASH_TABLE_SIZE;
}


/**
 * Compute hash level 2.
 * @param addr	Address to hash.
 * @return		Hash value.
 */
uint32_t mem_hash2(ppc_address_t addr)  {
    return (addr / MEMORY_PAGE_SIZE / PRIMARYMEMORY_HASH_TABLE_SIZE) % SECONDARYMEMORY_HASH_TABLE_SIZE;
}


/**
 * Get a secondary page table.
 * @parm mem	Memory to work on.
 * @param addr	Address of the page.
 */
secondary_memory_hash_table_t* mem_get_secondary_hash_table(
	memory_64_t *mem,
	ppc_address_t addr)
{
	uint32_t h1;
	secondary_memory_hash_table_t* secondary_hash_table;

	/* try to fetch the secondary hashtable */
	h1 = mem_hash1(addr);
	secondary_hash_table = mem->primary_hash_table[h1];

	/* if the secondary hashtable does'nt exists */
	if(!secondary_hash_table) {
		/* allocation of the secondary hashtable */
		secondary_hash_table = (secondary_memory_hash_table_t *)
			calloc(sizeof(secondary_memory_hash_table_t),1);

		if(secondary_hash_table == NULL)
			throw "Failed to allocate memory in mem_get_secondary_hash_table\n";
		mem->primary_hash_table[h1]=secondary_hash_table;
	}

	return secondary_hash_table;
}




#endif // __MEM_INTERN_H__
