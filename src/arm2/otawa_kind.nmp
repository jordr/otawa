
let NO_KIND		= 0x00000000
let IS_COND		= 0x00000001
let IS_CONTROL	= 0x00000002
let IS_CALL		= 0x00000004	// save PC before branching
let IS_RETURN	= 0x00000008
let IS_MEM		= 0x00000010
let IS_LOAD		= 0x00000020
let IS_STORE	= 0x00000040
let IS_INT		= 0x00000080
let IS_FLOAT	= 0x00000100
let IS_ALU		= 0x00000200	// basic arithmetic operations (like "+", "-")
let IS_MUL		= 0x00000400
let IS_DIV		= 0x00000800
let IS_SHIFT	= 0x00001000
let IS_TRAP		= 0x00002000
let IS_INTERN	= 0x00004000
let IS_MULTI	= 0x00008000
let IS_SPECIAL	= 0x00010000

// useful mode extensions
extend regShift
	reg_num = r.number
	no_shift = 0

extend immShift
	reg_num = r.number
	no_shift = shiftAmt == 0 && shiftKind != ROR

extend rotatedImmediate
	no_shift = v == 0

extend REG_LIST
	has_pc = r & (1 << 15)

// instruction extensions

extend B_Cond
	otawa_kind = IS_CONTROL
		| (if setl then IS_CALL else 0 endif)
		| (if cond.value == 14 then 0 else IS_COND endif)

extend BX_ARM
	otawa_kind = IS_CONTROL
		| (if rd == 14 then IS_RETURN else 0 endif)

extend MOV_shr
	otawa_kind =
		  (if cond.value == 14 && shifter_operand.reg_num == 15 && shifter_operand.no_shift
			then IS_RETURN | IS_CONTROL else 0 endif)
		| (if cond.value == 14 then 0 else IS_COND endif)
		| IS_ALU | IS_INT
 
extend CMP_imm, CMP_shr, CMN_imm, CMN_shr, TEQ_imm, TEQ_shr,
TST_imm, TST_shr
	otawa_kind =
		  IS_ALU
		| IS_INT
		| (if cond.value == 14 then 0 else IS_COND endif)
 
extend ADD_imm, ADC_imm, AND_imm, BIC_imm, EOR_imm, MOV_imm, MVN_imm,
ORR_imm, RSB_imm, RSC_imm, SBC_imm, SUB_imm
	otawa_kind =
		  IS_ALU
		| IS_INT
		| (if cond.value == 14 then 0 else IS_COND endif)
		| (if rd == 15 then IS_CONTROL else 0 endif)

extend ADC_shr, ADD_shr, AND_shr, BIC_shr, EOR_shr, MVN_shr,
ORR_shr, RSB_shr, RSC_shr, SBC_shr, SUB_shr, CLZ, SWP
	otawa_kind =
		  IS_ALU
		| IS_INT
		| (if cond.value == 14 then 0 else IS_COND endif)
		| (if rd == 15 then IS_CONTROL else 0 endif)	

extend LDM
	otawa_kind = IS_MEM | IS_MULTI | IS_LOAD
		| (if cond.value == 14 then 0 else IS_COND endif)
		| (if rn.number == 13 && reglist.has_pc then IS_CONTROL | IS_RETURN else 0 endif)

extend STM
	otawa_kind = IS_MEM | IS_MULTI | IS_STORE
		| (if cond.value == 14 then 0 else IS_COND endif)
	
extend LDR_imm, LDR_shr
 	otawa_kind =
 		  IS_MEM
 		| IS_INT
 		| IS_LOAD
 		| (if cond.value == 14 then 0 else IS_COND endif)
 		| (if rd == 15 then IS_CONTROL else 0 endif)
 		| (if rd == 15 && rn == 13 then IS_RETURN else 0 endif) 

extend STR_imm, STR_shr
 	otawa_kind =
 		  IS_MEM
 		| IS_INT
 		| IS_STORE
 		| (if cond.value == 14 then 0 else IS_COND endif)

extend STRH_imm, STRH_shr
 	otawa_kind =
 		  IS_MEM
 		| IS_INT
 		| (if cond.value == 14 then 0 else IS_COND endif)
 		| IS_STORE

extend LDRH_imm, LDRH_shr, LDRSB_imm, LDRSB_shr,
LDRSH_imm, LDRSH_shr
 	otawa_kind =
 		  IS_MEM
 		| IS_INT
 		| (if cond.value == 14 then 0 else IS_COND endif)
 		| IS_LOAD
 		| (if rd == 15 then IS_CONTROL else 0 endif)
 
extend SWI
	otawa_kind =
		  IS_CONTROL
		| IS_TRAP
 		| (if cond.value == 14 then 0 else IS_COND endif)

extend MLA, MUL
	otawa_kind =
		  IS_ALU
		| IS_INT
		| IS_MUL
 		| (if cond.value == 14 then 0 else IS_COND endif)
 		| (if rd == 15 then IS_CONTROL else 0 endif)


extend SMULL, UMULL, SMLAL, UMLAL
	otawa_kind =
		  IS_ALU
		| IS_INT
		| IS_MUL
 		| (if cond.value == 14 then 0 else IS_COND endif)
 		| (if rdhi == 15 || rdlo == 15 then IS_CONTROL else 0 endif)

extend MSR_imm, MSR_shr
	otawa_kind =
		  IS_ALU
		| IS_INT
 		| (if cond.value == 14 then 0 else IS_COND endif)
 
extend MRS
	otawa_kind =
		  IS_ALU
		| IS_INT
 		| (if cond.value == 14 then 0 else IS_COND endif)
 		| (if rn == 15 then IS_CONTROL else 0 endif)
