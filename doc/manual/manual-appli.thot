====== Writing an OTAWA Application ======

Basically, OTAWA is a framework providing a bunch of classes for static analysis and particularly Worst Case Execution Time Computation. Although OTAWA provides some ready-to-use utilities, more interesting is the implementation of an application filling exactly some needs or extending the OTAWA features.

To achieve this goal, the following skills are required :
  * a basic experience in C++,
  * some experience with Makefiles,
  * a solid knowledge about WCET and static analysis.

This tutorial will show how to make and compile a little application using @(OTAWA) framework. First of all, a working version of @(OTAWA) must be available(see Section @ref:install@).


===== Application Design =====

Once you have installed OTAWA, you can start to write your first OTAWA application. As a first example, we want to use OTAWA to apply basic IPET method on some embedded program (whose architecture is supported by OTAWA). Our program will include the following passes :
  - select the task entry point for which to compute the WCET,
  - compute the execution time of each basic block using an instruction-level simulator and the delta approach,
  - build the ILP system for the program control flow,
  - resolve it to get the WCET.



===== Source Header =====

Now, we will write a simple C++ source file to perform our work. We call it ''ipet.cpp'' and it will start with the following lines :
<code c>
#include <elm/io.h>
#include <otawa/otawa.h>
#include <otawa/ipet.h>

using namespace elm;
using namespace otawa;
</code>

The first include ''<elm/io.h>'' imports classes to perform outputs. ELM is a general purpose library delivered and used by @(OTAWA). It provides a lot of useful facilities including I/O support, generic data structures and OS abstractions.

The following inclusion ''<otawa/otawa.h>'' provides @(OTAWA) main classes while the next one, ''otawa/ipet.h'', is dedicated to IPET classes. The last two lines just open the namespaces where ELM and OTAWA classes lie in.


===== Main Function =====

Now, we can write the main function:

<code c>
int main(void) {
  try {
    WorkSpace *ws = MANAGER.load("program to analyze");
    ...
  }
  catch(elm::Exception& e) {
    cerr << "ERROR: " << e.message() << '\n';
  }
</code>

The first step is to load the program using the static object ''MANAGER'' that stores common resources used in @(OTAWA). The function ''load'' is used to open the file. It returns a ''WorkSpace'' object, that is, a location where the loaded binary file may be analyzed to get a WCET.

The binary file ''open()'' call is enclosed in a ''try { ... } catch(...)'' clause in order to catch possible errors and exception thrown by the ''load'' function. If any error is raised, the ''catch'' just stops the application and display the error message.

Most @(OTAWA) objects may throw exceptions when an error is encountered. Depending on the application needs, they can immediately processed or simply ignored to let the main function do the display work. The latter approach makes the program a bit easier to write and to read (providing that the allocated resources are fried).



===== Writing the Analysis =====

The easiest way to perform the IPET analysis it to call the ''otawa::ipet::WCETComputation'' code processor as below:
<code c>
    ipet::WCETComputation comp;
    comp.process(ws);
    cout << "the wcet is " << ipet::WCET(ws) << io::endl;
</code>

In @(OTAWA), a code processor is a piece of code that performs an analysis on the workspace. Usually, a workspace contains the program representation augmented with a lot of annotations produced by the code processors. As an instance, the last line is used to display the final ''ipet::WCET'' annotation linked to the workspace, that is, the WCET expressed in cycles.

The code processors work on the workspace and they are allowed to use already tied annotations, or to create their own annotations. Here, ''WCETComputation'' has computed the WCET and has linked it with the ''ipet::WCET'' annotation identifier. But computing a WCET is a big task involving many different code processors like CFG (Control Flow Graph) building, ILP (Integer Linear Programming) system generation, etc.

To achieve the trick, each code processor automatically records lists of required features and provided features (a feature is a list of annotations). Before a code processor can be launched, all its required features needs to be provided in the workspace. When a feature is missing, @(OTAWA) will look for a code processor to provide it. The code processor to launch to obtain feature may be a processor provided in the configuration, or a default processor tied to the feature. In any case, either a code processor is found and run (and in turn it will require some features that will trigger other code processors and so on), or the calculations stop and an error is displayed.

In our case, as only the final code processor -- ''WCETComputation'' -- is called, default code processors will be called to satisfy its required features. To observe this chain of analyzes,Â @(OTAWA) can be called with the annotation ''Processor::VERBOSE'' set to true as below:

<code c>
    PropList props;
    Processor::VERBOSE(props) = true;
    ipet::WCETComputation comp;
    comp.process(ws, props);
    cout << "the wcet is " << ipet::WCET(ws) << io::endl;
</code>

This piece of code displays all details about the performed computations and the processed code parts. Also, it demonstrates how annotations can be used to provide a configuration to the execution of a code processor. ''PropList'' is the base class of most @(OTAWA) classes and provide facilities to hang annotation (called //properties// in @(OTAWA) terminology). The source line containing the assignment to ''Processor::VERBOSE'' actually creates a new annotation with identifier ''Processor::VERBOSE'' and the value ''true'' and record it in the property list ''props'' (see Section @ref:props@ for more details).

To sum up, the configuration of the ''WCETComputation'' processoris based on an empty property list, ''props'' that is enriched by adding a property named ''Processor::VERBOSE'' which value is true. Then, the property list is passed to the ''process'' method of the code processor. This function launches the analysis of the processor on the given workspace with the given configuration.








===== Compiling the Sources =====

To be executed, the application described in the previous section has first to be compiled the application. As @(OTAWA) compilation is a bit complex to configure, it is advised to use a build system as, for instance, a //Makefile// as the one presented below:

<code make>
OTAWA_CONFIG	= otawa-config
PLUGINS         = 
APP         	= myapp
SOURCES         = myapp.cpp

CXXFLAGS        = $(shell $(OTAWA_CONFIG) --cflags $(PLUGINS))
LDLIBS          = $(shell $(OTAWA_CONFIG) --libs $(PLUGINS))

OBJECTS         = $(SOURCES:.cpp=.o)

$(APP): $(OBJECTS)
        $(CXX) $(CXXFLAGS) -o $@ $^ $(LDLIBS)
</code>

The utility ''otawa-config'' provides all details about @(OTAWA) installation directories and compilation flags: C++ flags, libraries to link, path to shared resources, etc. ''otawa-config'' can be found in the directory ''bin'' in the @(OTAWA) installation directory. It is advised to add this directory to the ''PATH'' variable to avoid to re-type the full path.

''PLUGINS'' are not used in this example but keeping this definition may be useful for latter development. @(OTAWA) comes with several plug-ins that can linked with an application, just by passing their name in the variable ''PLUGINS''. Yet, an explicit link with plug-in is not always required: @(OTAWA) is able to automatically retrieve and load a plug-in depending on the user feature or by using textual name to refer to code processors, features or annotation identifiers.

Beside, ''otawa-config'' can e used to get the list of all available plug-ins:
<code sh>
$ otawa-config --list-plugins
</code>


Building the application is as simple as typing:
<code sh>
$ make
</code>


===== Running the Application =====

Once all bug has been fixed and ''make'' has been successful, you get your executable analyzer that you can launch with (with //ELF_FILE// any binary file supported by @(OTAWA)):
<code sh>
$ ./myapp ELF_FILE
</code>

The output of the command is presented below for the file ''crc.elf'' compiled in the previous section:

<code>
</code>

One can see that the following analyses are performed:
  - the CFG are built -- ''CFGBuilder'',
  - the involved CFG are collected -- ''CFGCollector'',
  - the ILP variables are assigned -- ''VarAssignment'',
  - the ILP flow constraints are built -- ''BasicConstraintBuilder'',
  - the basic block execution time are computed -- ''TrivialBBTime'',
  - the ILP object function is built -- ''BasicObjectFunctionBuilder'',
  - the flow facts are loaded -- ''FlowFactLoader'',
  - and the WCET is computed -- ''WCETComputation''.

Yet, in all this work, something goes wrong: the computed WCET is -1, that is, no solution can be computed. The problem comes from the loop contained in the tested program. OTAWA can not automatically compute the bound of the loop and, consequently, the generated system has an infinite maximal value.

To get a right result, you have to provides loop bounds in a flow fact file. Refer to [[Computing a WCET]], "Specifying the Flow Facts" for a description of flow facts files. Actually, the flow fact file are managed by the ''FlowFactLoader'' processor. As no flow fact file was available, it gave up silently.










===== Specializing the Computation =====

OTAWA code processors chain themselves depending on the so-called ''Feature'' objects. A ''Feature'' simply asserts that a set of properties are available in the current workspace. To this end, each code processor declares its list of required features and provided framework. Shortly, required features are computed before the code processor execution is launched and provided features are granted once that the code processor has been executed.

If a required feature is not present, a default code processor is invoked to compute lacking information. Often, the default code processor is very simple and its results are very approximative but conservative overestimations of the WCET. This work is well illustrated by our application where the WCET is only computed with all default code processors of features. Yet, notice that several features provide a fully functional processor (''CFGBuilder'', ''CFGConstraintBuilder'').

Now, we will exploit the behavior of the feature system to specialize the performed analysis, that is, a feature is computed by its default processor only if it is not already defined. For example, we want to replace the coarse grain ''TrivialBBTime'' computation by the inter-block aware basic block timing Delta analysis [Engblom] implemented in the ''Delta'' code processor. To implement this, we have just to invoke this processor before the ''WCETComputation'' processor as in the following code:

<code c>
    PropList props;
    Processor::VERBOSE(props) = true;
    ipet::Delta delta;
    delta.process(ws, props);
    ipet::WCETComputation comp;
    comp.process(ws, props);
    cout << "the wcet is " << ipet::WCET(ws) << io::endl;
</code>

Now, we can compile again and launch the generated analyzer. Below is presented the interesting part of the output. You may notice that there is no more ''TrivialBBTime'' invocation that is replaced by ''Delta''.

<code>
</code>

At this point, you know how to customize the computation of the WCET. To go further, you have just to read the documentation of the different code processors to know:
  * which features are available,
  * how to configure it.
The auto-documentation of OTAWA code processors is available at ''INSTALL_DIR/share/Otawa/autodoc''.



===== Fast Way =====

The previous sections have presented the hard way to make an OTAWA application
but OTAWA implements some utilities and classes to simplify the work.

First, ''otawa-new'' is a small program to generate an OTAWA project. Just pass
the name of the project as argument and it generates a directory containing
the ''Makefile'' for your project:
<code sh>
$ otawa-new my_project
</code>
Then, you have just to configure the ''Makefile'' by editing it. 

Second, it is usually a burden and a repetitive task to scan the application
arguments, to open the binary file and to process each entry point passed
as argument. With the class otawa::Application, you have just to provide
the function to process the entry points:

<code cpp>
#include <otawa/app/Application.h>

using namespace otawa;

class MyApplication: public Application {
public:
	MyApplication: Application("MyApplication", Version(1, 0, 0)) {
		// initialization
	}

protected:
	virtual void work(const string &entry, PropList &props) throw (elm::Exception) {
		// do the work here
	} 
};

OTAWA_RUN(MyApplication)
</code>

Notice that the ''main'' is automatically handled by the ''OTAWA_RUN'' macro 
and the application class automatically supports ''-v'' and ''-h'' options.
You may additional options as below:

<code cpp>
class MyApplication: public Application {
public:
	MyApplication:
		Application("MyApplication", Version(1, 0, 0)),
		option1(*this, ...),
		option2(*this, ...)
	{ // initialization }

private:
	MyOption1 option1;
	MyOption2 option2;
};
</code>

Please, refer to the ''options'' module of ELM library to get details on the option classes (inheriting from ''elm::option::Option'').



===== Conclusion =====

In this tutorial, we have learned :
  * to write a little analyzer using the OTAWA API,
  * how to compile this application,
  * to change the default behaviour of an analysis by straight invocation of code processors.

Although OTAWA provides working analyses, the use of the framework is more valuable if we have to write new analyses and if we combine these analyses with the OTAWA framework. This will be presented in the next tutorial.
