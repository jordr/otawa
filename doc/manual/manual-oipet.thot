====== Computing a WCET ======

Although @(OTAWA) is designed as a generic framework to develop static analyses for WCET computation, some facilities are provided to compute WCET using dedicated scripts.

@(OTAWA) can implement several approaches to WCET computation, IPET (Implicit Path Enumeration Technique) is currently the more mature one. In addition, IPET seems to be the method that has been the most developed and that gave the most interesting and precise results.

In @(OTAWA), there are four ways to compute a WCET:
  * ''owcet'' command allows to perform computation based on script adapted to specific architecture,
  * the Eclispe plug-in gives access to architecture scripts in a more friendly graphic way inside the Eclipse IDE,
  * by writing your own program benefiting from the facilities of the framework (that is explored in different sections).


==== Using ''owcet'' ====

''owcet'' aims to compute WCET based on scripts describing the target
architecture hardware and to provided adapted analyses. To use ''owcet'',
you need a script adapted to your hardware: either you can write your
own script, or use a script automatically installed with @(OTAWA) core,
or to download an extension describing your hardware from the @(OTAWA)
website. Notice that, in @(OTAWA) 2, the tool ''otawa-install.py''
makes much easier the installation of a new extension. However, we will the builtin script, ''trivial'', to show the work
of ''owcet''. 

First, you need a binary application that is supported by @(OTAWA). In the core distribution, only binary loaders for ''ARM'' and ''PowerPC'' are provided by extensions for ''sparc'' and ''tricore'' are also available.

These binaries are usually obtained using a cross-compiler from your x86 platform. GCC on Linux OSes provides lots cross-compilers but cross-compilers also exists for other platforms. You can also look for pre-compiled binaries on the @(OTAWA) website.

Second, the program you want to process must fit the complexity of the software found in critical hard real-time systems. This mainly means that, if they contains dynamic memory allocation or formatted input-output (aka ''printf''), you will have hard time to make it working:
  * very big computation time (dominated by formatted input/output functions),
  * very imprecise analysis of the data cache,
  * very complex loops to bound.
Real-time applications are used split into tasks that are called periodically and which input-output are network accesses or sensors / actuators. Often, they work stand-alone on bare-metal platforms with a very tiny layer of OS.

For this example, we will uses the ''crc.c'' sample of the  [[http://www.mrtc.mdh.se/projects/wcet/benchmarks.html|MÃ¤lardalen benchmark]]:
<code c,line>
typedef unsigned char uchar;
#define LOBYTE(x) ((uchar)((x) & 0xFF))
#define HIBYTE(x) ((uchar)((x) >> 8))

unsigned char lin[256] = "asdffeagewaHAFEFaeDsFEawFdsFaefaeerdjgp";

unsigned short icrc1(unsigned short crc, unsigned char onech)
{
	int i;
	unsigned short ans=(crc^onech << 8);

	for (i=0;i<8;i++) {
		if (ans & 0x8000)
			ans = (ans <<= 1) ^ 4129;
		else
			ans <<= 1;
	}
	return ans;
}

unsigned short icrc(unsigned short crc, unsigned long len,
		    short jinit, int jrev)
{
  unsigned short icrc1(unsigned short crc, unsigned char onech);
  static unsigned short icrctb[256],init=0;
  static uchar rchr[256];
  unsigned short tmp1, tmp2, j,cword=crc;
  static uchar it[16]={0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15};

  if (!init) {
    init=1;
    for (j=0;j<=255;j++) {
      icrctb[j]=icrc1(j << 8,(uchar)0);
      rchr[j]=(uchar)(it[j & 0xF] << 4 | it[j >> 4]);
    }
  }
  if (jinit >= 0) cword=((uchar) jinit) | (((uchar) jinit) << 8);
  else if (jrev < 0)
    cword=rchr[HIBYTE(cword)] | rchr[LOBYTE(cword)] << 8;
  for (j=1;j<=len;j++) {
    if (jrev < 0) {
      tmp1 = rchr[lin[j]]^ HIBYTE(cword);
    }
    else {
      tmp1 = lin[j]^ HIBYTE(cword);
    }
    cword = icrctb[tmp1] ^ LOBYTE(cword) << 8;
  }
  if (jrev >= 0) {
    tmp2 = cword;
  }
  else {
    tmp2 = rchr[HIBYTE(cword)] | rchr[LOBYTE(cword)] << 8;
  }
  return (tmp2 );
}


int main(void)
{

  unsigned short i1,i2;
  unsigned long n;

  n=40;
  lin[n+1]=0;
  i1=icrc(0,n,(short)0,1);
  lin[n+1]=HIBYTE(i1);
  lin[n+2]=LOBYTE(i1);
  i2=icrc(i1,n+2,(short)0,1);
  return 0;
}
</code>
This benchmark is small enough for human understanding but provides any effects to demonstrate the work of @(OTAWA).

On a Linux platform, you can compile with:
<code sh>
> arm-linux-gnueabi-gcc crc.c -o crc.elf -g3 -static
</code>
The ''-static'' option ensures that the ''crc'' is compiled statically without any link to a dynamic library. ''-g3'' enables the debugging information generation in the executable: it is not mandatory but it will help us a lot for communicating with @(OTAWA).

Now, we can launch the WCET computation with the ''trivial'' script:
<code sh>
> owcet -t trivial crc.elf
WARNING: otawa::util::FlowFactLoader 1.4.0:no flow fact file for crc.elf
WARNING: otawa::ipet::FlowFactLoader 2.0.0:no limit for the loop at icrc + 0xdc (00008ea0).
WARNING: otawa::ipet::FlowFactLoader 2.0.0: in the context []
WARNING: otawa::ipet::FlowFactLoader 2.0.0:no limit for the loop at icrc + 0x248 (0000900c).
WARNING: otawa::ipet::FlowFactLoader 2.0.0: in the context []
WARNING: otawa::ipet::FlowFactLoader 2.0.0:no limit for the loop at icrc + 0x248 (0000900c).
WARNING: otawa::ipet::FlowFactLoader 2.0.0: in the context []
WARNING: otawa::ipet::FlowFactLoader 2.0.0:no limit for the loop at icrc1 + 0x98 (00008da4).
WARNING: otawa::ipet::FlowFactLoader 2.0.0: in the context []
WARNING: otawa::ipet::FlowFactConstraintBuilder 1.1.0:no flow fact constraint for loop at BB 5 (0000900c)
WARNING: otawa::ipet::FlowFactConstraintBuilder 1.1.0:no flow fact constraint for loop at BB 17 (00008ea0)
WARNING: otawa::ipet::FlowFactConstraintBuilder 1.1.0:no flow fact constraint for loop at BB 2 (00008da4)
ERROR: failed due to 3 (UNBOUNDED)
ERROR: no WCET computed (see errors above).
</code>

The output is a bit verbose but it is clear that the result was not computed. In fact, the warning lines inform us that some loop bounds are missing! As they are not bounded, they are considered as iterating an infinite number of times and hence the WCET cannot be obtained.

In fact, the loop bounding is a main issue we will encounter when we have to compute a WCET. It is a hard problem, as hard as proving a program tertminates. However, in the type of program targetted by OTAWA, the loops are often relatively simple and a bound can be computed. As bounding loops is not always feasible and may require a lot of computation power, it is performed in a preliminary phase of the WCET computation and maintained as soon as the source are not modified.


==== Specifying the Flow Facts by Hand ====

The first choice, to provide loop bounds (or more generally //flow facts//), is to fulfill a flow fact file suffixed by ''.ff''. Writing such a file is not very easy so that @(OTAWA) provides a tool to help you a bit, ''mkff''. Let execute it on our binary file:
<code sh>
> mkff crc.elf > crc.ff
</code>

Now, take a look to the obtained file:
<code>
checksum "crc.elf" 0x4cdc7edb;

// Function icrc (crc.c:23)
loop "icrc" + 0x248 ?; // 0000900c (crc.c:40)
loop "icrc" + 0xdc ?; // 00008ea0 (crc.c:32)

// Function icrc1 (crc.c:8)
loop "icrc1" + 0x98 ?; // 00008da4 (crc.c:12)
</code>

The ''.ff'' files have a simple text syntax where loops are identified by their address, absolute or relative to the functon containing it. The start address of the last loop is 0x98 bytes after the label of function ''icrc1''. Remark that ''mkff'' provides in comment (after ''//'') as many information as possible: the corresponding absolte address and, if the debugging information is available, the source file and the source line containing the loop. This help us to match the loop with the source to fulfill the missing bounds represented as questions marks.

The user has to edit by hand with any text editor the generated file and to replace each ''?'' mark by the program maximal loop count. The ''checksum'' must not be changed: it is used to check consistency of the flow fact file with the executable as header addresses may change when an executable is recompiled.





==== Details about the computation ====

To compute a WCET, ''oipet'' performs a lot of analyses on the program according to the selected options.
To get the detail of the performed analyses, one may pass the ''-v'' option and get an ouput listing like below:

<code>
  $ oipet executable_path -v
  Starting CFGCollector (1.0.0)
  Ending CFGCollector
  Starting otawa::TrivialBBTime (1.0.0)
          process CFG main
                  process BB 0 (00000000)
  ...
  WCET [/home/casse/Benchs/snu-rt/fibcall/fibcall:main] = 960
</code>

When an analysis starts, a ''Starting'' line is displayed with the name and the version.
Then an ''Ending'' is output when the analysis stops. The lines between start and stop output depends
upon the performed analysis.

In the sample above, the ''TrivialBBTime'' analysis displays the processed function CFG and, inside them,
the processed BB -- Basic Blocks. If there is an error somewhere, it is easy to locate it on the processed program.

To have details about the performed analyses, please refer to the auto-documentation in ''INSTALL_PATH/share/Otawa/autodoc'':
each analysis matches a documented C++ class.






===== ''owcet'' command =====

''oipet'' performs very basic WCET computations based on a bound set of analyzes. In addition, you have to provide
description of the different architecture features that may be quite complex in some cases. In the opposite, ''owcet''
allows to use WCET computation scripts dedicated to a specific microprocessor model. These scripts comes with own set
of hardware description files and possibly analyses supporing specific features of the microprocessor.
Several microprocessor scripts are available on the OTAWA site, @(OTAWA_SITE) and may be freely downloaded and compiled.

==== Basics of ''owcet'' ====

The ''owcet'' is usually invoked with the following syntax from the command line shell:
<code sh>
$ owcet -s SCRIPT EXE_FILE [TASK_NAME]
</code>

Where //SCRIPT// is the name of the script. The scripts are installed in the directory ''otawa-config --scripts''.
The script files have ''.osx'' for extension and the //SCRIPT// may be either the script name without extension, or a file path
designing a script file. To list the available scripts, you can use ''otawa-config'':
<code sh>
$ otawa-config --list-scripts
</code>

The //EXE_FILE// is the ELF file containing the executable and //TASK_NAME// is an optional argument giving the name
of the function representing the task. If //TASK_NAME// is omitted, the computation is performed for the ''main'' function.
 
As for ''owcet'', flow fact information (like loop bounds) may be required to achieve the computation. ''owcet'' supports the F4
flow fact format (as ''oipet'') but also the FFX format (based on XML) providing much more expressivity for the flow facts.
The FFX files may be edited by hand or generated by tools like oRange (described in the following section). Whatever the used format,
the flow facts may be passed implicitely with a file named //EXE_FILE//''.ff'' or //EXE_FILE//''.ffx'' according to the used format,
or by passing explicitely with the option ''-f'' or ''--flowfacts'':
<code sh>
$ owcet -s SCRIPT EXE_FILE [TASK_NAME] -f PATH_TO_FLOWFACT_FILE
</code>


==== Tuning the computation ====

Usually, the delivered scripts provide several configuration items: either a script represents a family of microprocessors,
or some properties on the environment of the microprocessor (that is the board it is mount on). To list the available
parameters, one can type the following command:

<code sh>
$ owcet -s SCRIPT EXE_FILE --list
</code>

Either one can let undefined a parameter (using the default value), or you can pass it a parameter to the computation
with option ''-p'' or ''--param'' passing as argument a string separated by an equal symbol ''=''. On the left side, stands the
parameter name and on the right side the parameter value:
<code sh>
$ owcet -s SCRIPT EXE_FILE -p PARAM1=VALUE1 -p PARAM2=VALUE2...
</code>





===== Producing the flowfacts =====



