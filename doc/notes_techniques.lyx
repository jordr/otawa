#LyX 1.3 created this file. For more info see http://www.lyx.org/
\lyxformat 221
\textclass report
\language frenchb
\inputencoding auto
\fontscheme pslatex
\graphics default
\paperfontsize default
\spacing single 
\papersize a4paper
\paperpackage a4wide
\use_geometry 0
\use_amsmath 0
\use_natbib 0
\use_numerical_citations 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language french
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Title

Notes techniques pour Otawa
\layout Standard


\begin_inset LatexCommand \tableofcontents{}

\end_inset 


\layout Section*

Lexique
\layout Description

AST Abstract Syntax Tree ou arbre de syntaxe abstraite.
 Il s'agit de la représentation de la structure du programme directement
 obtenu à partir de sa syntaxe en supprimant toute la partie symbolique.
\layout Description

CFG Control Flow Graph ou graphe de flot de contrôle.
 Cette représentation du programme fournit un graphe dont les sommets sont
 les blocs de base et les arcs le passage du flot de contrôle d'un bloc
 de base à un autre.
 Les CFG sont habituellement définis au niveau du sous-programme.
\layout Description

ILP Integer Linear Programming.
 Cette technique permet de maximiser une expression en fonction d'un système
 d'inégalités entières.
\layout Description

IPET Implicit Path Enumeration Technique.
 Cette technique d'évaluation du WCET d'un graphe de programme s'appuie
 sur la technique des ILP.
 Il s'agit de maximiser une équation entière en fonction d'un certain nombre
 de contraintes.
 
\layout Description

PCG Program Call Graph ou graphe d'appel de programme.
 Ce graphe permet de représenter les appels de sous-programmes.
 Les sommets du graphe sont les sous-programme et les arcs les appels de
 sous-programme.
 Pour un sous-programme donné, il y a autant d'arc sortant que d'appel de
 sous-programme.
\layout Chapter

Principes de base
\layout Section

Contraintes
\layout Standard

Otawa doit remplir les contraintes suivantes:
\layout Enumerate

Il doit permettre de traiter indifféremment toutes sortes de programmes
 exprimés à partir de sa représentation assembleur quel que soit l'architecture
 sous-jacente et quel que soit la représentation du programme.
\layout Enumerate

La représentation interne du programme doit permettre d'accrocher un maximum
 d'algorithmes différents d'analyse et de WCET.
\layout Enumerate

Un des principaux objectifs d'Otawa est de permettre la mise en oeuvre simple
 d'algorithmes d'analyse WCET.
\layout Enumerate

Le fonctionnement d'Otawa peut être soit automatique, soit interactif\SpecialChar ~
: il
 faut donc prévoir des mécanismes pour sauver et restaurer une session.
\layout Section

Espace d'application
\layout Standard

L'espace d'application initial d'Otawa représente le calcul de WCET:
\layout Itemize

Technique de calcul par IPET.
\layout Itemize

Calcul par interprétation abstraite.
\layout Itemize

Calcul par évaluation d'AST.
\layout Standard

Pour réaliser les calculs de WCET, il sera certainement aussi nécessaire
 de réaliser d'autres analyses sur le programme:
\layout Itemize

Calcul de CFG, d'AST et de PCG.
\layout Itemize

Analyse de donnée inter-procédurale pour obtenir les appels de sous-programme
 par pointeur.
\layout Itemize

Analyse de donnée inter-procédurale pour calculer les alias de référence
 mémoire.
\layout Itemize

Autres analyse sur la représentation haut niveau du programme (variables
 d'induction, etc).
\layout Standard

Un autre objectif d'Otawa est de fournir un cadre solide pour étudier les
 conséquences des optimisations par réordonnancement sur le calcul de WCET.
\layout Itemize

Réordonnancement au sein du bloc de base.
\layout Itemize

Dépliage des boucles ou pipe-line de boucle.
\layout Itemize

Super-bloc et hyper-bloc.
\layout Section

Propriétés et processeurs de code
\layout Standard

Pour atteindre les objectifs cités précédemment, Otawa se propose de mettre
 en place une structure minimale, aussi appelée 
\begin_inset Quotes fld
\end_inset 

représentation assembleur
\begin_inset Quotes frd
\end_inset 

 sur laquelle vont pouvoir s'accrocher différentes informations, aussi appelées
 propriétés.
 Ainsi, la structure de donnée obtenue est très peu contraignante et permet
 de combiner facilement différentes phases d'analyse sur différentes sous-partie
s de la représentation.
\layout Standard

Dans Otawa, on appelle processeur de code tout programme réalisant une opération
 sur la structure représentant le programme.
 On peut distinguer deux types de processeurs\SpecialChar ~
:
\layout Description

Analyseurs Les analyseurs, comme leur nom l'indique, analysent le code et
 laissent leur résultat sous forme de propriétés accrochées aux différentes
 parties du programme.
\layout Description

Transformeurs Les transformeurs modifient le code du programme et donc la
 structure de représentation du programme.
\layout Standard

Nous voyons ici que les propriétés accrochées aux différentes parties du
 programme permettent de faire le lien entre les différents processeurs.
 Un processeur peut utiliser les résultats obtenus à partir d'un autre processeu
r grâce à ces propriétés.
 Cela peut néanmoins impliquer deux modes de fonctionnement différents pour
 les processeurs de code\SpecialChar ~
:
\layout Description

Mode\SpecialChar ~
en\SpecialChar ~
prise Dans ce mode là, l'analyseur ou le transformeur se charge de
 lancer toutes les opérations qui lui sont nécessaires et s'exécute ensuite
 lui-même.
 Par exemple, un calcul de WCET prenant en compte le cache mémoire pourra
 lancer une analyse d'alias des références mémoire.
 Il sera donc assuré de trouver l'information qui lui est nécessaire dans
 la représentation du programme.
\layout Description

Mode\SpecialChar ~
libre Dans ce mode, l'analyseur ou le transformeur fera au mieux selon
 les informations disponibles dans la structure de donnée.
 Habituellement, les analyseurs en mode libre affineront leurs résultats
 à mesure que de nouvelles informations seront disponibles.
 Par exemple, un analyseur de WCET exploitant le cache mémoire utilisera
 les informations d'alias de référence quand elle est disponible.
 Dans le cas contraire, elle se rabattra par défaut sur une évaluation pessimist
e pour conserver la validité de son calcul.
\layout Standard

Le fonctionnement en mode en-prise ou en mode libre de processeurs d'analyse
 et de transformation dépendra beaucoup de la nature même du processeur.
 Le mode libre permet d'adapter plus facilement le processeur à toute sorte
 de contexte mais tous les algorithmes ne se prêtent pas à ce genre de fonctionn
ement.
 En contrepartie, un processeur en mode en-prise est souvent plus facile
 à développer mais est aussi plus coûteux en performances et, donc, difficile
 à appliquer de manière itérative.
\layout Standard

Enfin, on peut classifier les processeurs de code selon leur champ d'application
 dans le programme\SpecialChar ~
:
\layout Itemize

Niveau des instructions.
\layout Itemize

Niveau du sous-programme (utilisation du CFG ou des AST et des blocs de
 base).
\layout Itemize

Niveau du programme (utilisation du PCG).
\layout Standard

Évidemment, les processeurs agissant à différents niveaux peuvent interagir
 par l'intermédiaire des propriétés.
\layout Section

Les entrées/sorties
\layout Standard

Parmi les contraintes d'Otawa, on trouve la possibilité de permettre des
 analyses de WCET inter-actives.
 Cela a pour contrainte de nécessiter un environnement ergonomique pour
 l'utilisateur et principalement la possibilité de sauvegarder et de restaurer
 un espace de travail.
\layout Standard

Cette contrainte doit être prise en compte au sein de toutes les structures
 de données d'Otawa pour faciliter cette opération de sérialisation et de
 désérialisation.
 Pour permettre une prise en compte aussi large et simplifiée que possible,
 Otawa doit fournir à ses composants une interface abstraite\SpecialChar ~
:
\layout Itemize

Limitant au strict minimum le travail à réaliser sur les différents composants.
\layout Itemize

Permettant de varier la représentation sérialisée sous-jacente.
\layout Standard

L'interface abstraite utilisée pour la sauvegarde et la restauration se
 propose de de représenter les structures de données selon l'organisation
 ci-dessous, présentée en syntaxe abstraite\SpecialChar ~
:
\layout Standard
\align center 

\begin_inset  Tabular
<lyxtabular version="3" rows="11" columns="3">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\begin_inset Formula $information$
\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

:
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\begin_inset Formula $donnée\, littérale$
\end_inset 


\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

|
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\begin_inset Formula $liste\, ordonnée$
\end_inset 


\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

|
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard


\begin_inset Formula $liste\, nommée$
\end_inset 


\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\begin_inset Formula $liste\, ordonnée$
\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

:
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

liste(
\begin_inset Formula $information$
\end_inset 

)
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\begin_inset Formula $liste\, nommée$
\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

:
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

liste(
\begin_inset Formula $identificateur\times information$
\end_inset 

)
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\begin_inset Formula $donnée\, littérale$
\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

:
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

booléen
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

|
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

entier
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

|
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

réel
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

|
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

caractère
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

|
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

chaîne de caractère
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

|
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

référence
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard

Dans cette approche, l'information est vue soit comme des données littérales
 dont certains types de base sont directement supportés, soit des listes
 d'informations ordonnées (permettant aussi de représenter les listes non-ordonn
ées) ou des listes nommées.
 Les listes ordonnées correspondent à peu près aux tableaux et aux listes
 chaînées alors que les listes nommées permettent d'implanter facilement
 les structures et les tables d'association.
\layout Standard

Comme représentation sérialisée, le XML semble s'imposer actuellement d'autant
 plus que\SpecialChar ~
:
\layout Itemize

Il se prête facilement à notre représentation structurée.
\layout Itemize

Le chargement des sessions n'a, à priori, pas de contraintes de performances.
\layout Itemize

Le XML étant un format texte, il plus facile à déboguer, à vérifier et,
 éventuellement, à modifier à la main.
\layout Itemize

Il pourra éventuellement faciliter l'échange de session entre différentes
 applications.
\layout Itemize

Il existe pour C et C++ de nombreux moteurs parseurs XML gratuits.
\layout Standard

Remplir la contrainte de session utilisateur peut aussi apporter d'autres
 avantages\SpecialChar ~
:
\layout Itemize

Possibilité de dupliquer une session de travail pour réaliser différentes
 politiques d'analyse.
\layout Itemize

Possibilité de reprise en cas de plantage d'Otawa ou du système de support,
 plantage dont la probabilité augmente à mesure que les algorithmes sont
 complexes et longs à exécuter.
\layout Chapter

Représentation du code
\layout Standard

Il existe presque autant de représentation de programme qu'il y a de famille
 d'analyseur ou de transformeur de code.
 Pour fournir un cadre consistant à tous ces algorithmes, Otawa doit être
 capable de supporter un maximum de transformation.
\layout Section

Représentation binaire
\layout Standard

La représentation binaire consiste à représenter le programme sous une forme
 équivallente ou proche de sa représentation lors d'une exécution normale.
 Cette forme est généralement construite par le chargeur du code machine.
 Elle est néanmoins de trop bas niveau pour être facilement utilisable dans
 Otawa.
\layout Standard

Les problèmes suivant se posent:
\layout Itemize

A priori, les machines Von Neuman ne font pas la différence entre la mémoire
 dévolue au code et la mémoire utilisée pour les données.
\layout Itemize

Il est pratiquement impossible de lier les éléments du programme en binaire
 avec des propriétés provenant du langage source.
\layout Standard

Néanmoins, le format des programmes exécutables fournit de nombreuses informatio
ns pour mieux comprendre le binaire et pour constituer, dans Otawa, la représent
ation assembleur.
\layout Section

Représentation assembleur
\layout Standard

La représentation assembleur est la plus proche de ce à quoi ressemblera
 le programme quand il sera exécuté sur un processeur réel.
 Sur cette représentation binaire, Otawa superpose une hiérarchie de structure
 de donnée permettant de consulter et modifier plus facilement cette structure
 binaire.
 Cette hiérarchie est constitué des éléments suivants, du plus petit élément
 au plus grand\SpecialChar ~
:
\layout Description

Instruction Il s'agit de la brique de base d'un programme, l'élément le
 plus important du programme.
 Comme Otawa doit fournir un environnement mulit-architecture, il s'agit
 d'une abstraction de l'instruction réelle fournissant toute sorte d'information
 pour les algorithmes traitant ce niveau: nature de l'instruction, opérandes,
 type des opérandes, adressage de la mémoire ou cible d'un branchement.
\layout Description

Elément\SpecialChar ~
de\SpecialChar ~
programme Il s'agit là d'une quantité abstraite d'instruction ou
 de données permettant de les différentier au sein du niveau hiérarchique
 supérieur.
 Un élément de donnée pourra représenter une ou plusieurs variables ou constante
s du programme tandis que un élément de code pourra représenter un ou plusieurs
 sous-programmes.
 Suivant les architectures et les formats d'exécutables, ces éléments peuvent
 se situer dans la même structure ou séparemment.
\layout Description

Segment Le segment est une unité classique constituant le programme correspondan
t à différentes contraintes de l'architecture.
 En général, le segments sont distingués par leurs fonctions\SpecialChar ~
: code exécutable,
 données constantes, données variables, données non-initialisées.
 Sur une architecture disposant d'une MMU, les pages constituant les segments
 sont configurées de manière à refléter leur utilisation et protéger les
 accès illicites.
\layout Description

Fichier Dans le domaine du temps, le programme est généralement représenté
 par un fichier unique\SpecialChar ~
: l'édition des liens est faite statiquement et le
 programme obtenu est prêt à être exécuté tel quel.
 On peut néanmoins imaginer que Otawa pourra être utilisé dans des configuration
s moins limitées et, dans ce cas, il faudra être capable de gérer l'édition
 de lien dynamique et donc la présence de plusieurs fichiers de programme.
\layout Description

Processus Il s'agit du sommet de la hiérarchie et correspond à peu près
 au processus d'un système d'exploitation évolué\SpecialChar ~
: un espace mémoire où le
 programme est implanté.
 Le processus fournie le point d'attache des fichiers mais aussi un environnemen
t où il est possible de simuler le programme.
\layout Standard

Comme son nom l'indique, la représentation assembleur est déjà une abstraction
 par rapport au code machine.
 Par exemple, les addresses relative ou absolues sont remplacées par des
 adresses symboliques représentées par des propriétés ou même des pseudos
 instructions insérées parmi les instructions.
 Cette abstraction permet de visiter et modifier plus facilement le programme
 traité.
\layout Standard

Néanmoins, que ce soit à la sauvegarde du code ou pour une simulation, il
 est parfois nécessaire de rétablir une représentation binaire du programme
 et donc de régénérer le code machine.
 On parle alors de 
\begin_inset Quotes fld
\end_inset 

mapping
\begin_inset Quotes frd
\end_inset 

, c'est-à-dire de mise en correspondance des éléments de la représentation
 assembleur avec une implantation réelle dans la machine.
\layout Standard

La représentation assembleur a été choisie, à priori, comme représentation
 principale du programme dans Otawa.
 Néanmoins, elle apporte quelques avantages directement visible\SpecialChar ~
:
\layout Itemize

Il est facile de créer la représentation assembleur à partir de chargeur
 de code déjà existant.
 GLISS fournie, par exemple, un chargeur Elf pour le code PowerPC.
\layout Itemize

Cette représentation est fondamentale dans le sens où, dès qu'on désire
 faire du calcul de WCEt précis, il est nécessaire d'accéder aux instructions
 en assembleur.
\layout Itemize

Elle est également nécessaire pour les transformations de code qui devront,
 à un moment donnée, produire du code assembleur pour former un nouveau
 programme.
\layout Standard

Il reste à valider la prédominance de cette représentation pour remplir
 les objectifs de Otawa.
\layout Section

Représentation par CFG et PCG
\layout Standard

Cette représentation classique du domaine des compilateur est encore très
 utilisée et permet de faire fonctionner de nombreux algorithmes.
 Le programme entier est représenté pa run PCG alors que chaque sous-programme
 est associé à un CFG formant un graphe de blocs de base.
\layout Standard

Dans le cadre d'Otawa, les blocs de base sont représentées par des pseudo-instru
ctions.
 Un bloc de base s'étend de sa pseudo-instruction marqueur, précédant la
 première instruction du bloc de base, jusqu'au marquer du bloc de base
 suivant.
 Un bloc de base vide est toujours insérée à la fin du code pour rendre
 le parcours des blocs de base plus régulier.
\layout Standard

Chaque bloc de base définit deux références\SpecialChar ~
:
\layout Description

Branchement\SpecialChar ~
non-pris Il s'agit du bloc de base suivant le bloc de base courant
 dans le cas où le branchement, terminant le bloc de base, n'est pas pris.
 Cette référence peut être nulle si me branchement final est inconditionnel.
\layout Description

Branchement\SpecialChar ~
pris Il s'agit du bloc de base cible du branchement terminant
 le bloc de base courant.
 Ce référent peut être si aucun branchement ne termine le bloc de base ou
 la cible ne peut pas être connue dans le cas d'un branchement indirect
 (branchement sur registre ou retour de sous-programme).
\layout Standard

Le CFG est alors constitué par une référence sur le bloc de base, point
 d'entrée du sous programme correspondant.
 En suivant les réferents de branchement pris et non-pris, on reconstruit
 le graphe du CFG.
 
\layout Standard

Il a été choisi d'insérer des pseudo-instruction dans la représentation
 assembleur du programme pour marquer le début des blocs de base.
 Cela permettait d'éviter de lier le CFG à une instruction particulière
 qui peut être à tout moment supprimée ou déplacée.
 Cependant, cela pose quelques problèmes comme la nécessité implicite que
 le marqueur accompagne la vie de son bloc de base alors même que certains
 algorithmes n'en connaissant pas l'existence.
 Ce point est aussi à valider.
\layout Standard

Enfin, il faut noter que la représentation du CFG avec seulement successeur
 dans le flot (branchement pris, non-pris) ne permet pas de représenter
 tous les programmes, notamment ceux avec branchement multiple comme l'implantat
ion des switch en C et des appels de pointeurs de fonction.
\layout Section

Représentation par AST
\layout Standard

Les AST permettent de retrouver la structure de contrôle initiale du programme.
 Elle simplifie notamment la recherche des boucles, ds sélections et les
 algorithmes qui les traitent.
 L'AST fournit dans Otawa permet de modéliser simplement les structures
 de contrôle avec les noeuds suivants\SpecialChar ~
:
\layout Description

Nop Cet AST représente un ensemble nul d'instruction.
\layout Description

Block Il s'agit de bloc d'instruction simple, ne contenant aucun flot de
 contrôle reconnu par les AST.
 Néanmoins, le bloc d'instruction assembleur résultant de la compilation
 peut contenir des branchements, par exemple, lors de l'évaluation des opérateur
s && et || en circuit court.
\layout Description

Call Il s'agit d'un bloc particulier se terminant par un appel de sous-programme.
 Il est intéressant de différentier les deux pour traiter plus facilement
 les appels, plutôt que d'alourdir les AST avec des données supplémentaires.
\layout Description

Seq Il s'agit d'une représentation de la séquence.
 Même si les programmes permettent d'enchaînner plusieurs instructions dans
 une séquence, Otawa en fournira une vue currifiée en chaînnant des séquences
 de deux AST.
\layout Description

If Il s'agit de la représentation de la sélection.
 Ce noeud accepte trois sous-AST\SpecialChar ~
: l'évaluation de la condition, l'AST de
 la partie 
\begin_inset Quotes fld
\end_inset 

then
\begin_inset Quotes frd
\end_inset 

, l'AST de la partie 
\begin_inset Quotes fld
\end_inset 

else
\begin_inset Quotes frd
\end_inset 

.
 Si la partie 
\begin_inset Quotes fld
\end_inset 

else
\begin_inset Quotes frd
\end_inset 

 n'est pas disponible dans le code source, son AST est le 
\emph on 
Nop
\emph default 
.
\layout Description

While Il s'agit de la répétition avec test avant exécution du corps.
 Ici aussi, deux sous-AST permettent de représenter la condition et le corps
 de la boucle.
\layout Description

DoWhile Il s'agit de la répétition avec test après exécution du corps.
 On trouve deux sous-AST représentant la condition et le corps de la boucle.
\layout Description

For Il s'agit d'une répétition plus complexe avec évaluation de la condition
 avant exécution du corps.
 On trouve, en fait, quatre sous-AST\SpecialChar ~
: l'initialisation, la condition, l'incrémen
tation et le corps.
\layout Standard

En conservant la représentation assembleur comme structure initiale, deux
 possibilités peuvent se présenter pour représenter les AST\SpecialChar ~
:
\layout Enumerate

Les AST sont construits sur la représentation assembleur et enregistrés
 sous forme de propriété ou de pseudo-instruction.
\layout Enumerate

Les AST const construits au dessus de la couche CFG, c'est-à-dire, à base
 de bloc de base.
\layout Standard

Il faut faire une première remarque\SpecialChar ~
: il n'y a pas une correspondance complète
 entre les blocs de code AST (feuilles de l'arbre AST) et les blocs de base.
 Par exemple, la structure 
\emph on 
for
\emph default 
 définie dans la figure\SpecialChar ~

\begin_inset LatexCommand \ref{cap:Problème-de-correspondance}

\end_inset 

\SpecialChar ~
(a) possède des blocs d'intialisation et d'incrémentation qui pourront éventuell
ement être includes dans les blocs de base précédents, respectivement, le
 code avant l'itération et le corps de la boucle.
 La figure\SpecialChar ~

\begin_inset LatexCommand \ref{cap:Problème-de-correspondance}

\end_inset 

\SpecialChar ~
(b) montre ce découpage en bloc de base.
\layout Standard


\begin_inset Float figure
wide false
collapsed false

\layout Standard


\begin_inset Minipage
position 1
inner_position 0
height "0pt"
width "45col%"
collapsed false

\layout Standard


\begin_inset Formula $code_{1}$
\end_inset 

;
\layout Standard

for(
\begin_inset Formula $code_{2}$
\end_inset 

; 
\begin_inset Formula $code_{3}$
\end_inset 

; 
\begin_inset Formula $code_{4}$
\end_inset 

); 
\layout Standard


\begin_inset Formula $\quad code_{5}$
\end_inset 


\layout Standard


\begin_inset Formula $code_{6}$
\end_inset 

;
\layout Standard
\added_space_top medskip 
(a) Programme C initial.
\end_inset 


\begin_inset Minipage
position 1
inner_position 0
height "0pt"
width "45col%"
collapsed false

\layout Standard


\begin_inset  Tabular
<lyxtabular version="3" rows="8" columns="3">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\begin_inset Formula $code_{1}$
\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

bloc de base 1
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\begin_inset Formula $code_{2}$
\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

loop:
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\begin_inset Formula $code_{3}$
\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

bloc de base 2
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

if false goto end
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\begin_inset Formula $code_{5}$
\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

bloc de base 3
\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\begin_inset Formula $code_{4}$
\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

goto loop
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

\end_inset 
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

end:
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\begin_inset Formula $code_{6}$
\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

bloc de base 4
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\layout Standard
\added_space_top medskip 
(b) Traduction en assembleur.
\end_inset 


\layout Caption


\begin_inset LatexCommand \label{cap:Problème-de-correspondance}

\end_inset 

Problème de correspondance de la boucle 
\emph on 
for
\emph default 
 avec les blocs de base.
\end_inset 


\layout Standard

Ensuite, il faut remarquer que la représentation sous forme de CFG n'est
 pas nécessaire au traitement de programme sous forme AST.
 De plus, il semble, mais cela reste à démontrer, que représenter le programme
 comme un ensemble de couches rendre plus difficile les transformations
 du programme qui doivent conserver la consistence de chacune des représentation
s\SpecialChar ~
:
\layout Itemize

Il faudra d'abord définir la transformation de l'assembleur vers la représentati
on CFG.
\layout Itemize

Ensuite, il faudra définir la transformation du CFG vers les AST tout en
 prenant en compte les problèmes de correspondance vus précédemment.
\layout Standard

Pour toutes ces raisons, il semble plus intéressant de représenter CFG et
 AST parallèlement sur la représentation primaire de l'assembleur.
 Finalement, il faut noter que bien que la structure soit sémantiquement
 supérieure à l'assembleur, CFG et AST peuvent être vues comme des propriétés
 particulières des instructions du programme.
 Transformer le programme tout en conservant la cohérence de ces représentations
 n'est finalement que fournir des règles de transformation pour ces propriétés
 spécifiques.
\layout Chapter

Structure d'Otawa
\layout Section

Structure générale
\layout Standard

La figure\SpecialChar ~

\begin_inset LatexCommand \ref{cap:Structure-générale-d'Otawa}

\end_inset 

 montre la structure générale d'Otawa.
\layout Standard


\begin_inset Float figure
wide false
collapsed false

\layout Standard


\begin_inset Graphics
	filename /home/casse/IRIT/otawa/doc/architecture_globale.eps
	scale 80

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{cap:Structure-générale-d'Otawa}

\end_inset 

Structure générale d'Otawa
\end_inset 


\layout Standard

La représentation des programmes est le point central, le pivot d'Otawa.
 Les liens sur la figure ne sont pas orienté car les échanges avec la représenta
tion centrale sont bidirectionnels pour la plupart.
 Ils représentent les accès à l'API d'Otawa sur la représentation du programme.
\layout Standard

C'est sur cette représentation que se branche et fonctionne le reste des
 modules d'Otawa\SpecialChar ~
:
\layout Description

Chargeurs En bleu, à gauche sur la figure, représente des modules responsable
 du chargement des programmes à partir de diverses méthodes.
 Par exemple, on trouve ici un loader GLISS utilisant la bibliothèque GLISS
 pour charger des fichiers au format ELF.
 Le loader Heptane lui procède à la compilation de fichiers et à leur chargement
 sous forme Elf, enrichi avec des informations sur les AST.
 Comme dernier exemple, on prend le cas d'un chargeur GNU BinUtils utilisant
 cette bibliothèque pour accéder à toute une série de formats différents.
 Cependant, les chargeurs ne sont pas obligés de seulement accéder à une
 implantation binaire du programme.
 Par exemple, Salto traite les programmes à partir de leur forme assembleur
 et peut très bien représenter un chargeur Otawa.
\layout Description

Analyseurs En vert, en haut.
 Les analyseurs exploitent la représentation du programme pour réaliser
 certains calculs.
 En général, les résultats de ces calculs sont stockés dans la représentation
 du programme sous forme de propriétés.
 On prend ici comme exemple un analyseur de WCET maison, un analyseur IPET
 et même un analyseur d'alias.
\layout Description

Transformeurs En rouge, en base.
 Ces processeur de code transforme le programme à partir de sa représentation.
 Ce sont généralement des algorithmes d'optimisation comme, par exemple,
 les réordonnancements par liste, les dépliages de boucle ou des optimisations
 par trace comme le super-bloc.
\layout Description

Interfaces\SpecialChar ~
utilisateur A droite, en jaune.
 Otawa est aussi articulé pour fournir une interface utilisateur afin de
 permettre à l'utilisateur d'intervenir sur les analyses et les transformations
 de code ou de fournir des informations supplémentaires.
 Le projet Otawa fournit déjà une interface texte, 
\emph on 
oshell
\emph default 
, mais devrait fournir dans un futur proche une interface graphique plus
 ergonomique.
 Néanmoins, Otawa doit aussi pouvoir être utilisable comme bibliothèque
 d'autre programme de traitement de code.
\layout Section

Les chargeurs
\layout Standard

La représentation des programmes d'Otawa n'est qu'une interface abstraite
 du programme à traiter.
 Sur cette représentation abstraite, Otawa fournit des services pour construire
 les CFG, les AST ou autre.
 La représentation concrète du programme est réalisée par le chargeur qui
 adapte l'interface Otawa aux différents formats d'exécutable.
\layout Standard

Le chargeur implante donc les modules suivants\SpecialChar ~
:
\layout Itemize

Informations sur l'architecture et la plate-forme d'exécution du programme.
\layout Itemize

Représentation concrète du programme.
\layout Itemize

Sémantique des instructions du programme afin de pouvoir comprendre les
 instructions et/ou les données.
\layout Itemize

Procédure pour convertir l'exécutable binaire en sa représentation concrète
 sous Otawa.
\layout Itemize

Eventuellement, la conversion inverse pour sauvegarder un programme optimisé.
\layout Standard

Dans Otawa, les chargeurs sont identifiés par un indentificateur alphanumérique
 comme 
\begin_inset Quotes fld
\end_inset 

heptane
\begin_inset Quotes frd
\end_inset 

 ou 
\begin_inset Quotes fld
\end_inset 

gliss
\begin_inset Quotes frd
\end_inset 

.
 Otawa fournit une liste de tous les chargeurs disponibles et, dans un avenir
 proche, il sera possible d'utiliser des plug-in sous forme de bibliothèque
 partagée qui seront retrouvées à partir de leur nom.
\layout Standard

Pour ce qui est de l'architecture, un identificateur alphanumérique plus
 complexe est adopté afin de couvrir un maximum de cofniguration existante.
 Il est composé de la manière suivante\SpecialChar ~
:
\layout Quotation


\begin_inset Formula $processeur$
\end_inset 


\family typewriter 
\series bold 
-
\family default 
\series default 

\begin_inset Formula $format$
\end_inset 


\family typewriter 
\series bold 
-
\family default 
\series default 

\begin_inset Formula $plate-forme$
\end_inset 


\layout Standard

Les composants ont la signification suivante\SpecialChar ~
:
\layout Description


\begin_inset Formula $processeur$
\end_inset 

 Il s'agit de l'identification du processeur.
 La description est réalisée par des identificateurs de plus en plus précis
 séparés par des 
\begin_inset Quotes fld
\end_inset 

/
\begin_inset Quotes frd
\end_inset 

.
 En premier lieu, on trouvera la famille du processeur puis, éventuellement,
 le modèle d'un processeur donné.
 Par exemple, 
\family typewriter 
\series bold 
powerpc
\family default 
\series default 
 représente la famille de tous les processeurs PowerPC tandis que 
\family typewriter 
\series bold 
powerpc/ppc755
\family default 
\series default 
 représente le modèle précis PowerPC 755.
\layout Description


\begin_inset Formula $format$
\end_inset 

 Le format représente le type d'encodage du programme exécutable.
 Parmi les formats couranys, on trouve Elf ou Coff.
 On peut affiner en donnant après un 
\begin_inset Quotes fld
\end_inset 

/
\begin_inset Quotes frd
\end_inset 

, le type du chargeur à utiliser.
 Par exemple, 
\family typewriter 
\series bold 
elf
\family default 
\series default 
 représente un chargeur Elf tandis que 
\family typewriter 
\series bold 
elf/gliss
\family default 
\series default 
 désigne explicitement le chargeur Elf de GLISS.
\layout Description


\begin_inset Formula $plate-forme$
\end_inset 

 La plate-forme identifie l'architecture précise dans laquelle va fonctionner
 le programme et le processeur.
 La plate-forme représente tous les périphériques du processeurs incluant
 la mémoire, la mémoire de masse, les E/S et toute autre particularité de
 la machine hôte.
 Tout comme les autres composants, elle peut être décrite par raffinnement
 successif en séparant chaque identificateur par des 
\begin_inset Quotes fld
\end_inset 

/
\begin_inset Quotes frd
\end_inset 

.
 Pour l'instant, on utilise seulement une plate-forme générique décrite
 par l'identificateur 
\family typewriter 
\series bold 
gliss
\family default 
\series default 
.
\layout Standard

L'architecture de base utilisée dans Otawa peut être décrite par la chaîne
 alphanumérique suivante\SpecialChar ~
:
\layout Quotation


\family typewriter 
\series bold 
powerpc/ppc755-elf/gliss-gliss
\layout Standard

Attention\SpecialChar ~
! Il faut remarquer que tous les chargeurs ne gèrent pas toutes
 les architectures.
 Le chargeur GLISS accepte, pour l'instant, seulement des programmes pour
 les architectures PowerPC alors que le chargeur Heptane supporte les architectu
res PowerPC et x86.
\layout Standard

L'identifiant primaire des composant 
\begin_inset Formula $processeur$
\end_inset 

 et 
\begin_inset Formula $plate-forme$
\end_inset 

 permette de décrire des familles générales de processeur et leur modèle
 de programmation et nécessitent, en général, du code spécialisé pour pouvoir
 les traiters.
\layout Standard

Les identifiants secondaires, par contre, fournissent des informations plus
 précises sur les ressources matérielles, il s'agit plutôt du modèle d'exécution.
 Parmi ces informations, on trouvera la description du pipe-line et des
 tables de réservation, la taille et la description des caches mémoire,
 les latences des instructions, des accès au cache et à la mémoire, etc.
\layout Standard

Etant donné que ces éléments sont très variables d'un modèle à un autre
 ou d'une plate-forme à une autre, il pourra être intéressant de disposer
 d'un format de fichier dédié permettant à l'utilisateur de facilement définir
 ses contraintes propres.
\layout Section

Les processeurs de code
\layout Standard

Les processeurs de code, analyseurs ou transformeurs, travaille au sein
 de la représentation du programme.
 Nous avons vu que la représentation primaire du programme est basée sur
 les instructions mais qu'elle permet facilement d'accrocher toutes de propriété
s annexes permettant, par exemple, de représenter les CFG ou les AST.
\layout Standard

De manière à automatiser facilement les outils utilisant Otawa, les processeurs
 de code devront fournir une interface qui pourra être exploitée facilement
 par l'interface utilisateur ou par les autres processeurs de code.
 Cette interface rendra disponible les informations suivantes\SpecialChar ~
:
\layout Itemize

Un nom permettant de retrouver le processeur ou de le charger sous forme
 de plug-in.
\layout Itemize

Un niveau de fonctionnement\SpecialChar ~
: programme, sous-programme (CFG ou AST), bloc
 de base, répétition, etc.
\layout Itemize

Un type\SpecialChar ~
: analyseur ou transformeur.
\layout Itemize

Une liste de paramètres que l'utilisateur puisse configurer la transformation.
\layout Standard

On peut imaginer mettre en place une hiérarchie des processeurs basées leur
 type, puis différencié en classes et sous-classes.
 Par exemple, l'analyse de WCET par IPET classique sur CFG pourra être appelée
 
\family typewriter 
\series bold 
analyzer/IPET/CFG
\family default 
\series default 
 alors que la méthod par Heptane pourra être appelée 
\family typewriter 
\series bold 
analyzer/IPET/AST/Heptane
\family default 
\series default 
.
 De même, le réordonnancement par liste top-bottom pourra être nommé 
\family typewriter 
\series bold 
transformer/scheduling/list/top-bottom
\family default 
\series default 
.
\layout Section

Les interfaces utilisateurs
\layout Standard

Les interfaces utilisateurs ont pour objectif de fournir une représentation
 du programme lisible par l'utilisateur et de laisser ce dernier déclencher
 et de configurer les processeurs de code.
\layout Standard

On peut faire une liste générale, mais non exhaustive, des interactins types
 dans le cadre d'Otawa\SpecialChar ~
:
\layout Itemize

Chargement d'un programme.
\layout Itemize

Lancement d'un calcul WCET sur tout ou une partie du programme.
\layout Itemize

Consultation des calculs WCET du programme.
\layout Itemize

Sauvegarde ou restauration d'une session précédente d'Otawa.
\layout Itemize

Définition de contraintes pour les entrées du programme.
\layout Itemize

Saisie d'information des occurences de certaines partie du programme.
\layout Itemize

Fourniture de jeux de tests significatifs.
\layout Itemize

Lancement d'une simulation du programme.
\layout Itemize

Consultation des durées résultats de la simulation.
\layout Itemize

Lancement d'analyseurs spécifiques comme le calcul d'alias.
\layout Itemize

Optimisation de tout ou une partie du programme.
\layout Itemize

Sauvegarde d'un programme optimisé.
\layout Chapter

Alternatives pour la représentation des programmes
\layout Chapter

Etude des algorithmes d'analyse et de transformation du code
\layout Chapter

Règles de transformation des propriétés pour Otawa
\layout Chapter

Guide d'utilisation
\layout Section


\begin_inset LatexCommand \ref{sec:Démarrage}

\end_inset 

Démarrage
\layout Standard

Otawa est basé sur la notion de 
\begin_inset Quotes fld
\end_inset 

manager
\begin_inset Quotes frd
\end_inset 

 et de 
\begin_inset Quotes fld
\end_inset 

framework
\begin_inset Quotes frd
\end_inset 

.
 Un manager gère l'ensemble des données centralisées d'une séance de travail.
 Le framework, par contre, représente une session de travail sur un programme
 donné.
 Pour créer le manager, il suffit de créer l'objet du même nom\SpecialChar ~
:
\layout LyX-Code

#include <otawa/manager.h>
\layout LyX-Code

using namespace otawa;
\layout LyX-Code

Manager manager = new Manager();
\layout Standard

Pour créer le framework, il faut avoir un fichier exécutable à charger et
 définir selon quelles modalités (plate-forme, chargeur), il va être utilisé.
 Pour l'instant, il n'existe que le chargeur, 
\family typewriter 
Loader::LOADER_PowerPC_GLiss
\family default 
, mais d'autres pourront être créés par la suite.
 Pour créer le framework, on va construire une liste de propriété précisant
 tous les détails à propos du chargement du programme.
\layout LyX-Code

PropList args;
\layout LyX-Code

args.set<Loader *>(Loader::ID_LoaderName, &Loader::LOADER_Gliss_PowerPC);
\layout LyX-Code

FrameWork *fw = manager->load(path_to_executable, args);
\layout Standard

Il existe de nombreuses autres options qu'il est possible de passer comme
 arguments du chargement d'un fichier comme 
\family typewriter 
ID_Platform
\family default 
, 
\family typewriter 
ID_Loader
\family default 
, 
\family typewriter 
ID_PlatformName
\family default 
, 
\family typewriter 
ID_LoaderName
\family default 
, 
\family typewriter 
ID_PlatformId
\family default 
, 
\family typewriter 
ID_Argc
\family default 
, 
\family typewriter 
ID_Argv
\family default 
 et 
\family typewriter 
ID_Envp
\family default 
.
 Vous pouvez vous reporter à la documentation automatique pour plus de détails.
\layout Standard

A partir de là, il est possible d'utiliser toutes les méthodes du framework
 pour explorer ou modifier le programme.
\layout Section

Parcours de CFG
\layout Standard

Pour parcourir les CFG d'un programme exécutable, il faut d'abord construire
 un framework, voire 
\begin_inset LatexCommand \ref{sec:Démarrage}

\end_inset 

.
 Ensuite, il faut obtenir soit la structure CFGInfo qui fournie la liste
 des CFG, soit le CFG de démarrage du programme.
 Pour obtenir, le CFG de démarrage, il faut faire\SpecialChar ~
:
\layout LyX-Code

#include <otawa/cfg.h>
\layout LyX-Code

using namespace otawa;
\layout LyX-Code

CFG *start_cfg = framework->getStartCFG();
\layout LyX-Code

if(!start_cfg)
\layout LyX-Code

  // Erreur !
\layout Standard

Le résultat peut être nul si le fichier exécutable ne contient pas de point
 d'entrée.
\layout Standard

Pour traiter l'ensemble des CFG du programme, on obtient la structure CFGInfo
 puis on explore la liste des CFG\SpecialChar ~
:
\layout LyX-Code

#include <elm/datastruct/Iterator.h>
\layout LyX-Code

#include <otawa.cfg.h>
\layout LyX-Code

using namespace otawa;
\layout LyX-Code

CFGInfo *info = framework->getCFGInfo();
\layout LyX-Code

for(Iterator<CFG *> cfg(info->cfgs()); cfg; cfg++)
\layout LyX-Code

  // Traitement du CFG.
\layout Standard

Pour parcourir le CFG, il faut obtenir le bloc de base, point d'entrée du
 graphe puis suivre les arcs 
\begin_inset Quotes fld
\end_inset 

taken
\begin_inset Quotes frd
\end_inset 

 et 
\begin_inset Quotes fld
\end_inset 

not taken
\begin_inset Quotes frd
\end_inset 

.
 Attention\SpecialChar ~
! Un CFG peut contenir des circularités dans son graphe.
\layout LyX-Code

AutoPtr<BasicBlock> bb = cfg->entry();
\layout LyX-Code

AutoPtr<BasicBlock> taken = bb->getTaken();
\layout LyX-Code

if(taken)
\layout LyX-Code

  // Traitement du bloc de base destination du branchement pris.
\layout LyX-Code

AutoPtr<BasicBlock> not_taken = bb->getNotTaken();
\layout LyX-Code

if(not_taken)
\layout LyX-Code

  // Traitement du bloc de base en séquence.
\layout Standard

La forme AutoPtr<BasicBlock> permet de traiter un pointeur dynamique sur
 le bloc de base.
 Ceci est nécessaire pour gérer automatiquement l'allocation et la désallocation
 saine du bloc de base lorsqu'on modifie le CFG.
 A part cela, ces pointeurs s'utilisent comme des pointeurs classiques.
\layout Standard

Il est possible d'obtenir de nombreuses informations du bloc de base\SpecialChar ~
:
\layout LyX-Code

bool is_call = bb->isCall();          // Appel de sous-programme
\layout LyX-Code

bool is_return = bb->isReturn()       // Retour de sous-programme
\layout LyX-Code

bool unknown = bb->isTargetUnknown(); // Cible de branchement inconnue
\layout LyX-Code

int size = bb->getBlockSize();        // Taille du bloc de base
\layout Standard

Des cibles de branchements inconnues se produisent lorsque l'adresse de
 branchement est obtenue par indirection ou lorsqu'il s'agit d'un appel
 système.
 Attention\SpecialChar ~
! Les appels de sous-programme sont matériallisés comme des arcs
 normaux du CFG mais ils pointent en réalité vers le premier bloc de base
 du CFG du sous-programme appelé.
\layout Standard

Pour parcourir un bloc de base, il suffit d'utiliser l'objet Iterator de
 la bibliothèque Elm\SpecialChar ~
:
\layout LyX-Code

for(Iterator<Inst *> inst(*b); inst; inst++)
\layout LyX-Code

  // Traitement de l'instruction inst
\the_end
